/*
	name:  uBOXSR
	description: avotoko's uBlock Origin Experimental Scriptlets Resource
	author: avotoko
	homepage: https://github.com/avotoko/ubo-resource
	install: add this file url to 'userResourcesLocation' in 'advanced settings'
*/
"use strict";

/// avotoko-fake-promise.js
/// alias avotoko-fp.js
/// alias avotoko-promise-patch.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-promise]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"), a.push("{{11}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	log("arg:", arg);
	// parameters: <invoke type>, <value>, <executor pattern>, <stack trace pattern>, <option>...
	let invoke = arg[0], val = arg[1], execPattern = arg[2], stPattern = arg[3], opts = parseOpts(arg.slice(4));
	if (! opts){ return; }
	log("options:", opts);
	if (! ["resolve", "reject"].includes(invoke)){ log("error: wrong invoke type:", invoke); return; }
	try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return; }
	opts.debug && log("value:", val);
	if (! execPattern){ log("error: executor pattern required"); return; }
	if (! (execPattern = parsePattern(execPattern))){ return; }
	opts.debug && log("executor pattern:", execPattern);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window, prop = "Promise";
	obj[prop] = new Proxy(obj[prop], {
		construct: function(target, args, newTarget){
			const executor = "" + args[0], st = makeSt(),
				match = execPattern.test(executor) && stPattern.test(st);
			if (match){
				log("faked", invoke, val, "aganst", executor);
				if (invoke === "resolve"){
					return new target((resolve,reject)=>{setTimeout(resolve, 1, val)});
				}
				else {
					return new target((resolve,reject)=>{setTimeout(reject, 1, val)});
				}
			}
			else {
				opts.log && log(executor + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
			}
			return Reflect.construct(target, args, newTarget);
		}
	});
	log("monitoring");
})();

/// avotoko-on-handler-defuser.js
/// alias avotoko-ohd.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-on-handler-defuser]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['body', "copy|selectstart|contextmenu", 'return!1', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <window|document|selector>, <event list>, <function pattern>, <stack trace pattern>, <option>...)
	let sel = arg[0], event = arg[1], fnPattern = arg[2], stPattern = arg[3], opts = parseOpts(arg.slice(4));
	if (! opts){ return; }
	log("options:", opts);
	if (! sel){ log("error: selector required"); return; }
	if (! event){ log("error: event required"); return; }
	event = (function(){ return event.split("|").map(e=>e.trim()).filter(e=>e); })();
	if (event.length === 0){ log("error: event name not listed"); return; }
	opts.debug && log("event list", event);
	if (! (fnPattern = parsePattern(fnPattern))){ return; }
	opts.debug && log("function pattern", fnPattern);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack pattern", stPattern);
	let obj = sel === "window" ? window : sel === "document" ? Document.prototype : HTMLElement.prototype;
	event.forEach(name=>{
		let prop = "on" + name;
		let des = findPropertyDescriptor(obj, prop, opts);
		if (! des || ! des.get || ! des.set){ log("error:", prop, "descriptor get/set not found"); return; }
		if (! des.configurable){ log("error:", prop, "descriptor is not configurable"); return; }
		Object.defineProperty(obj, prop, {
			get(){
				return des.get.call(this);
			},
			set(v){
				let fnText = "" + v,
					st = makeSt(),
					match = (! this.matches || this.matches(sel)) && fnPattern.test(fnText) && stPattern.test(st);
				if (match){
					log("defused", this, prop, fnText);
				}
				else {
					opts.log && log(this, prop, fnText  + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
					des.set.call(this, v);
				}
			},
			enumerable: true,
			configurable: true,
		});
	});
	log("monitoring");
})();

/// avotoko-fake-element-property.js
/// alias avotoko-fep.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-element-property]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function parseProps(args){
		let props = {}, more = [];
		for (let i = 0 ; i < args.length ; i++){
			let a = args[i], idx = a.indexOf(":"), key, val;
			if (idx === -1){
				more = args.slice(a === "eova" ? i + 1 : i);
				break;
			}
			key = a.substring(0, idx).trim(), val = a.substring(idx + 1).trim();
			if (! key){ log("error: empty property name:", a); return {}; }
			if (props.hasOwnProperty(key)){ log("error: multiple defined property name:", a); return {}; }
			if (val = val || void 0){
				try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return {}; }
			}
			props[key] = val;
		}
		return {props, more};
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	function derived(obj, from){
		while (obj){
			if (obj === from){ return true; }
			obj = Object.getPrototypeOf(obj);
		}
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['body', 'innerHTML:"<br />"', '', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <selector>, <property>,,, <dom i/f>, <stack trace pattern>, <option>...)
	let sel = arg[0], {props, more} = parseProps(arg.slice(1));
	if (! sel){ log("error: selector required"); return; }
	if (! props){ return; }
	log("props:", props, "more:", more);
	let domif = more[0] || "HTMLElement", stPattern = more[1], opts = parseOpts(more.slice(2));
	if (! opts){ return; }
	log("options:", opts);
	opts.debug && log("properties:", props);
	opts.debug && log("dom i/f:", domif);
	if (! window[domif]){ log("error:", domif, "is not defined"); return; }
	if (! derived(window[domif],  HTMLElement)){ log("error:", domif, "is not derived from HTMLElement"); return; }
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window[domif].prototype;
	Object.keys(props).forEach(prop=>{
		let _val,
			val = props[prop], 
			des = findPropertyDescriptor(obj, prop, opts) || {};
		if (des.hasOwnProperty("configurable") && ! des.configurable){ log("error:", prop, "is not configurable"); return; }
		Object.defineProperty(obj, prop, {
			get(){
				let v = des.get ? des.get.call(this) : des.hasOwnProperty("value") ? des.value : _val;
				try {
					if (this.matches(sel)){
						let st = makeSt(),
							match = stPattern.test(st);
						if (match){
							log("faked get", this, prop, v, "as", val);
							return val;
						}
						else {
							opts.log && log("get", this, prop, v  + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
						}
					}
				}
				catch (e){ log(e.type || "error", ":", e.message, ":", sel) }; 
				return v;
			},
			set(v){
				des.set ? des.set.call(this, v) : des.hasOwnProperty("value") ? (des.value = v) : (_val = v);
			},
			enumerable: true,
			configurable: true,
		});
	});
	log("monitoring");
})();

/// avotoko-fake-gettime-speed.js
/// alias avotoko-fgts.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-gettime-speed]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['1000', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <magnification>, <stack trace pattern>, <option>...)
	let mag = arg[0], stPattern = arg[1], opts = parseOpts(arg.slice(2));
	if (! opts){ return; }
	log("options:", opts);
	if (isNaN(mag = mag * 1)){ log("error: wrong magnification"); return; }
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = Date.prototype, prop = "getTime", start = 0;
	obj[prop] = new Proxy(obj[prop], {
		apply: function(target, thisArg, args) {
			let st = makeSt(),
				match = stPattern.test(st),
				val = Reflect.apply(target, thisArg, args);
			if (match){
				start === 0 && (start = val);
				val = start + Math.ceil((val - start) * mag);
				val < 0 && (val = 0);
				log("faked", prop, "as", val);
				return val;
			}
			else {
				opts.log && log(prop, "as", val, (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : " "));
			}
			return val;
		}
	});
	log("monitoring");
})();

/// avotoko-fake-queryselector-argument.js
/// alias avotoko-fake-getelement-argument.js
/// alias avotoko-fqsa.js
/// alias avotoko-fgea.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-queryselector-argument]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['document', "getElementsByTagName", 'head', 'body', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <document|selector>, <method list>, <argument pattern>, <net argument>, <stack trace pattern>, <option>...)
	let sel = arg[0], props = arg[1], argPattern = arg[2], newArg = arg[3], stPattern = arg[4], opts = parseOpts(arg.slice(5)), method = {querySelector:!0, querySelectorAll:!0, getElementById:!0, getElementsByClassName:!0, getElementsByTagName:!0, getElementsByTagNameNS:!0};
	if (! opts){ return; }
	log("options:", opts);
	if (! sel){ log("error: document or selector required"); return; }
	if (! props){ log("error: method list required"); return; }
	props = props.split(/[ \|]/).map(e=>e.trim()).filter(e=>!!e);
	if (props.length === 0){ log("error: method required"); return; }
	opts.debug && log("method list", props);
	if (props.some(e=>! method[e])){ log("error: wrong method. support", Object.keys(method).join(", ")); return; }
	if (! (argPattern = parsePattern(argPattern))){ return; }
	opts.debug && log("argument pattern", argPattern);
	if (! newArg){ log("error: new argument required"); return; }
	opts.debug && log("new argument", newArg);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack pattern", stPattern);
	let obj = sel === "document" ? document : HTMLElement.prototype, nMonitoring = 0;
	props.forEach(prop=>{
		if (typeof obj[prop] !== "function"){
			log("error:", prop, "in", obj.constructor.name, "is not function");
			return;
		}
		++nMonitoring;
		obj[prop] = new Proxy(obj[prop], {
			apply: function(target, thisArg, args) {
				try {
					if (thisArg === document || thisArg.matches(sel)){
						let i = prop.endsWith("NS") ? 1 : 0,
							argSel =  args[i],
							st = makeSt(),
							match = argPattern.test(argSel) && stPattern.test(st);
						if (match){
							log("faked", thisArg, prop, argSel, "as", newArg);
							args[i] = newArg;
						}
						else {
							opts.log && log(thisArg, prop, argSel + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
						}
					}
				}
				catch(e){ log(e.type, e.message, ":", sel); }
				return Reflect.apply(target, thisArg, args);
			}
		});
	});
	if (nMonitoring > 0){ log("monitoring"); }
})();

/// avotoko-fake-computed-style.js
/// alias avotoko-fcs.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-computed-style]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function parseCssText(cssText){
		let o = {}, n = 0;
		try {
			cssText.split(";").forEach(decl=>{
				if (decl.trim()){
					let i = decl.indexOf(":"), p = decl.substring(0, i).trim(), v = decl.substring(i+1).trim();
					if (! p){ throw Error("wrong css declaration: " + decl); }
					o[p] = v, n++;
				}
			});
		}
		catch (e){ log("error:", e.message); return; }
		if (n === 0){ log("error: css has no declaration"); return; }
		return o;
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return Object.assign({owner: obj}, des);
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"), a.push("{{11}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['#left_nav, #right_nav, .main_preview + div, .logo', ,"display:;", '/debugger|anonymous/', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <selector>, <pseudo-element pattern>, <css>, <stack trace pattern>, <opt>,,,)
	let sel = arg[0], pePattern = arg[1], css = arg[2], stPattern = arg[3], opts = parseOpts(arg.slice(4));
	if (! opts){ return; }
	log("options:", opts);
	if (! sel){ log("error: selector required"); return; }
	opts.debug && log("selector:", sel);
	if (! (pePattern = parsePattern(pePattern))){ return; }
	opts.debug && log("pseudo-element pattern:", pePattern);
	if (! (css = parseCssText(css))){ return; }
	opts.debug && log("css:", css);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window , prop = "getComputedStyle";
	obj[prop] = new Proxy(obj[prop], {
		apply: function(target, thisArg, args) {
			let e = args[0], pe/* pseudo-element */ = args[1], style = Reflect.apply(target, thisArg, args),
				st = makeSt();
			if (style){
				try {
					if (e.matches(sel) && pePattern.test(pe)){
						opts.log && log("got target", e, " " + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
						let prop = "getPropertyValue";
						style[prop] = new Proxy(style[prop], {
							apply: function(target, thisArg, args) {
								let property = args[0], v = Reflect.apply(target, thisArg, args);
								if (css.hasOwnProperty(property)){
									let st = makeSt(), match = stPattern.test(st);
									if (match){
										log("faked", prop, e, property, '"' + v + '"', "as", '"' + css[property] + '"');
										return css[property];
									}
									else {
										opts.log && log(prop, e, property, '"' + v + '"' + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
									}
								}
								return v;
							}
						});
						Object.keys(css).forEach(property=>{
							let val = css[property], 
								des = findPropertyDescriptor(style, property, opts) || {},
								des2 = Object.getOwnPropertyDescriptor(style, property);
							if (! (des.get/*firefox*/ || des.hasOwnProperty("value")/*chrome*/)){
								log("error:", property, "descriptor has no getter/value"); return;
							}
							if (des2 && des2.get){
								log(style[property] === val ? "warning:" : "error:", property, "descriptor getter already defined");
								return;
							}
							Object.defineProperty(style, property, {
								get(){
									let st = makeSt(),
										match = stPattern.test(st),
										v = des.get ? des.get.call(this) : des.value;
									if (match){
										log("faked get", e, property, '"' + v + '"', "as", '"' + val + '"');
										return val;
									}
									else {
										opts.log && log("get", e, property, '"' + v + '"' + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
									}
									return v;
								},
								enumerable: true,
								configurable: true,
							});
						});
					}
				}
				catch(e){ log(e.type, e.message); }
			}
			return style;
		}
	});
	log("monitoring");
})();

/// avotoko-fake-object-property.js
/// alias avotoko-fop.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-object-property]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function parseProps(args){
		let props = {}, more = [];
		for (let i = 0 ; i < args.length ; i++){
			let a = args[i], idx = a.indexOf(":"), key, val;
			if (idx === -1){
				more = args.slice(a === "eova" ? i + 1 : i);
				break;
			}
			key = a.substring(0, idx).trim(), val = a.substring(idx + 1).trim();
			if (! key){ log("error: empty property name:", a); return {}; }
			if (props.hasOwnProperty(key)){ log("error: multiple defined property name:", a); return {}; }
			if (val = val || void 0){
				try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return {}; }
			}
			props[key] = val;
		}
		return {props, more};
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	function parseChain(chain){
		let prop = [], s = chain, m;
		if (! (m = s.match(/^(\w+)(.*)/))){ log("error: chain must start with identifier"); return; }
		m[1] !== "window" && prop.push("window");
		prop.push(m[1]), s = m[2];
		while (s){
			if (! (m = s.match(/(\.(\w+)|\['(.+)'\]|\["(.+)"\])(.*)/))){ log("error: wrong property"); return; }
			prop.push(m[2] || m[3] || m[4]), s = m[5];
		}
		if (prop.length === 1){ log("error: chain has no property"); return; }
		return prop;
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	// arg = ['setTimeout', 'toString:"function(){[native code]}"', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <object>, <property>..., <stack trace pattern>, <option>...)
	let chain = arg[0], {props, more} = parseProps(arg.slice(1));
	if (! props){ return; }
	log("props:", props, "more:", more);
	let stPattern = more[0], opts = parseOpts(more.slice(1));
	if (! opts){ return; }
	log("options:", opts);
	if (! (chain = parseChain(chain))){ return; }
	opts.debug && log("object:", chain);
	opts.debug && log("properties:", props);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window;
	for (let i = 1 ; i < chain.length ; i++){
		try {
			obj = obj[chain[i]];
			if (! obj){ log("error:", chain.slice(0,i+1).join("."), "not defined"); return; }
		} catch(e){ log(e.type || "error", ":", e.message, ":", chain.slice(0,i+1).join(".")); return; }
	}
	opts.debug && log("object:", obj);
	Object.keys(props).forEach(prop=>{
		let _val,
			val = props[prop], fval = function(){ return props[prop]; };
			des = findPropertyDescriptor(obj, prop, opts) || {};
		if (des.hasOwnProperty("configurable") && ! des.configurable){ log("error:", prop, "is not configurable"); return; }
		Object.defineProperty(obj, prop, {
			get(){
				let v = des.get ? des.get.call(this) : des.hasOwnProperty("value") ? des.value : _val;
				let st = makeSt(), match = stPattern.test(st);
				if (match){
					log("faked get", this, prop, v, "as", val);
					return typeof v === "function" ? fval : val;
				}
				else {
					opts.log && log("get", this, prop, v  + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
				}
				return v;
			},
			set(v){
				des.set ? des.set.call(this, v) : des.hasOwnProperty("value") ? (des.value = v) : (_val = v);
			},
			enumerable: true,
			configurable: true,
		});
	});
	log("monitoring");
})();

/// avotoko-fake-object-method.js
/// alias avotoko-fom.js
(function() {
	const log = function(){
		const _log = console.log, concat = Array.prototype.concat, from = Array.from;
		return function log(){
			_log.apply(console, concat.call(["[avotoko-fake-object-method]"], from(arguments)));
		}
	}();
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	const makeSt = function(){
		const ua =navigator.userAgent, includes = String.prototype.includes,
				split = String.prototype.split, slice = Array.prototype.slice,
				join = Array.prototype.join, _Error = Error;
		return function makeSt(){
			let i = includes.call(ua, "Chrome") ? 3 : includes.call(ua, "Firefox")  ? 2 : 2;
			return join.call(slice.call(split.call(_Error().stack, "\n"), i), "\n");
		}
	}();
	const toString = function(){
		const map = Array.prototype.map, join = Array.prototype.join,
			push = Array.prototype.push, pop = Array.prototype.pop, 
			forEach = Array.prototype.forEach, a_includes = Array.prototype.includes,
			s_includes = String.prototype.includes, substring = String.prototype.substring,
			keys = Object.keys, sym_toString = Symbol.prototype.toString;
		return function toString(v, depth, recur){
			depth = depth || 0, recur = recur || [];
			if (v instanceof Array){
				return "[" + join.call(map.call(v, e=>toString(e, depth+1, recur)), ", ") + "]";
			}
			else if (v instanceof Element){
				return v.outerHTML;
			}
			else if (v instanceof Node){
				return v.nodeName + " " + toString(v.textContent || "");
			}
			else if (typeof v === "object" && v !== null){
				if (a_includes.call(recur, v)){ return "[recursive object]"; }
				else if (depth > 2){ return "[too deep object]"; }
				push.call(recur, v);
				let s = "";
				forEach.call(keys(v), k => {
					s += ", " + k + ": " + toString(v[k], depth+1, recur);
				});
				pop.call(recur);
				return s ? "{ " + substring.call(s, 2) + " }" : "{}";
			}
			else if (typeof v === "symbol"){
				return sym_toString.call(v);
			}
			else {
				return "" + v;
			}
		}
	}();
	function parseVArgs(args){
		let noarg, more = [], hash = {}, maxIdx = -1;
		for (let i = 0 ; i < args.length ; i++){
			let a = args[i].trim(), idx;
			if (! (m = a.match(/^(\d+):(.*)/))){
				if (a === "noarg"){
					if (maxIdx !== -1){ log("error: 'noarg' with arg(s)"); return {}; }
					noarg = true;
				}
				more = args.slice(["noarg", "eova"].includes(a) ? i + 1 : i);
				break;
			}
			idx = m[1] * 1;
			if (hash.hasOwnProperty(idx)){ log("error: multiple defined arg index:", a); return {}; }
			if ((hash[idx] = parsePattern(m[2].trim())) === void 0){ return {}; }
			maxIdx = Math.max(maxIdx, idx);
		}
		let varg = new Array(maxIdx + 1), v;
		for (let i = 0 ; i < maxIdx + 1; i++){
			varg[i] = hash[i] || /(?:)/;
		}
		varg.noarg = noarg;
		return {varg, more};
	}
	function parseChain(chain, type, minLength){
		let prop = [], s = chain, m;
		if (! (m = s.match(/^(\w+)(.*)/))){ log("error: chain must start with identifier"); return; }
		m[1] !== "window" && prop.push("window");
		prop.push(m[1]), s = m[2];
		while (s){
			if (! (m = s.match(/(\.(\w+)|\['(.+)'\]|\["(.+)"\])(.*)/))){ log("error: wrong property"); return; }
			prop.push(m[2] || m[3] || m[4]), s = m[5];
		}
		if (prop.length < minLength){ log("error: chain has no " + type); return; }
		return prop;
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['atob', '"hello"', 'noarg', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <object.method>, <return value>, <arg pattern>..., <stack trace pattern>, <option>...)
	let chain = arg[0], prop, val = arg[1], {varg, more} = parseVArgs(arg.slice(2)); 
	if (! varg){ return; }
	log("varg:", (varg.noarg ? "noarg" : varg), "more:", more);
	let stPattern = more[0], opts = parseOpts(more.slice(1));
	if (! opts){ return; }
	log("options:", opts);
	if (! (chain = parseChain(chain, "method", 2))){ return; }
	prop = chain.splice(chain.length - 1)[0];
	opts.debug && log("object:", chain);
	opts.debug && log("method:", prop);
	if (val = val || void 0){
		try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return; }
	}
	opts.debug && log("return value:", typeof val === "string" ? toString(val) : val);
	opts.debug && log("arg pattern:", varg);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window;
	for (let i = 1 ; i < chain.length ; i++){
		try {
			obj = obj[chain[i]];
			if (! obj){ log("error:", chain.slice(0,i+1).join("."), "not defined"); return; }
		} catch(e){ log(e.type || "error", ":", e.message, ":", chain.slice(0,i+1).join(".")); return; }
	}
	opts.debug && log("object:", obj);
	if (typeof obj[prop] !== "function"){log("error:", prop, "is not function"); return;}
	obj[prop] = new Proxy(obj[prop], {
		apply: function(){
			const map = Array.prototype.map, join = Array.prototype.join, 
				every = Array.prototype.every, slice = Array.prototype.slice,
				split = String.prototype.split, test = RegExp.prototype.test,
				Reflect_apply = Reflect.apply;
			return function(target, thisArg, args) {
				const argsText = join.call(map.call(args, (e,i) => i + ":" + toString(e)) ,", "),
					st = makeSt(),
					match = (varg.noarg ? args.length === 0 : args.length === 0 ? varg.length === 0 : every.call(varg, (rex,i)=> test.call(rex, toString(args[i]))))
								&& test.call(stPattern, st);
				if (match){
					log("faked", thisArg, prop, argsText);
					return val;
				}
				else {
					opts.log && log(thisArg, prop, argsText, (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
				}
				return Reflect_apply(target, thisArg, args);
			}
		}()
	});
	log("monitoring");
})();

/// avotoko-no-shadow-root.js
/// alias avotoko-nosr.js
(function() {
	const log = function(){
		const _log = console.log, concat = Array.prototype.concat, from = Array.from;
		return function log(){
			_log.apply(console, concat.call(["[ avotoko-no-shadow-root]"], from(arguments)));
		}
	}();
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	const makeSt = function(){
		const ua =navigator.userAgent, includes = String.prototype.includes,
				split = String.prototype.split, slice = Array.prototype.slice,
				join = Array.prototype.join, _Error = Error;
		return function makeSt(){
			let i = includes.call(ua, "Chrome") ? 3 : includes.call(ua, "Firefox")  ? 2 : 2;
			return join.call(slice.call(split.call(_Error().stack, "\n"), i), "\n");
		}
	}();
	function parseOptions(s){
		s = s || "";
		const available = {
			"delay": v=> ! isNaN(v*1),
		};
		let options = {}, ar = s.split(" ").filter(e=>e);
		for (let i = 0 ; i < ar.length ; i++){
			let opt = ar[i], idx = opt.indexOf(":"), key, val;
			if (idx === -1){ log("error: ':' missed at", opt); return; }
			key = opt.substring(0, idx).trim(), val = opt.substring(idx + 1).trim();
			if (! key){ log("error: option name required:", opt); return; }
			if (! val){ log("error: option value required:", opt); return; }
			if (! available.hasOwnProperty(key)){ log("error: unknown option:", opt); return; }
			if (! available[key](val)){ log("error: wrong value:", opt); return; }
			if (options.hasOwnProperty(key)){ log("error: multiple defined option:", opt); return; }
			options[key] = val;
		}
		return options;
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = []; //arg = ['div', 'delay:100', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <selector>, <options>, <stack trace pattern>, <option>...)
	let sel = arg[0] || "*", options = arg[1], stPattern = arg[2], opts = parseOpts(arg.slice(3));
	if (! opts){ return; }
	log("debug options:", opts);
	opts.debug && log("selector:", sel);
	if (! (options = parseOptions(options))){ return; }
	options.delay = options.hasOwnProperty("delay") ? options.delay * 1 : 0;
	opts.debug && log("command options:", options);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	const observe = function(){
		const _setTimeout = setTimeout,
				Element_remove = Element.prototype.remove,
				Array_forEach = Array.prototype.forEach;
		const observer = new MutationObserver((mutations, observer)=>{
			Array_forEach.call(mutations, (m,j)=>{
				if (m.type === "childList"){
					m.addedNodes.forEach((e,i)=>{
						opts.log && log("added and removing", e);
						if (options.delay === 0){
							Element_remove.call(e);
						}
						else {
							_setTimeout.call(null, function(e, remove){
								Element_remove.call(e);
							}, options.delay, e, Element_remove);
						}
					});
				}
			});
		});
		return observer.observe.bind(observer);
	}();
	const patch = (function(){
		const _forEach = Array.prototype.forEach;
				_defineProperty = Object.defineProperty,
				_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
				_getOwnPropertyNames = Object.getOwnPropertyNames,
				_bind = Function.prototype.bind,
				_toString = Function.prototype.toString,
				_toLocaleString = Function.prototype.toLocaleString,
				_Reflect_apply = Reflect.apply;
		const patchedFunc = {};
		const patchFunc = function(target, callback, opts){
			opts = opts || {};
			opts.debug && log("[patch] patching function:", target.name);
			let temp = {
				[target.name]: function(){
					return callback(target, this, arguments, new.target);
				},
			}, copy = temp[target.name];
			_forEach.call(_getOwnPropertyNames(target), prop=>{
				copy[prop] = target[prop];
			});
			_defineProperty(copy, "toString", { value: _bind.call(target.toString, target) });
			_defineProperty(copy, "toLocaleString", { value: _bind.call(target.toLocaleString, target) });
			_defineProperty(copy.toLocaleString, "name", { value: "toLocaleString" });
			_defineProperty(copy.toLocaleString, "toString", { value: _bind.call(Function.prototype.toString, target.toLocaleString) });
			const depth = "protectionDepth" in opts ? opts.protectionDepth : 2;
			opts.debug && log("[patch] protection depth:", depth);
			for (let obj = copy.toString, 
				obj2 = copy.toLocaleString.toString, 
				toString = _bind.call(_toString, _toString),
				i = 0 ; i < depth ; obj = obj.toString, obj2 = obj2.toString, i++){
				_forEach.call([obj, obj2], obj=>{
					_defineProperty(obj, "name", { value: "toString" });
					_defineProperty(obj, "toString", { value: toString });
				});
			}
			return copy;
		}
		const patch = function (obj, prop, callback, opts){
			opts = opts || {};
			const org = _getOwnPropertyDescriptor(obj, prop), copy = {};
			if (! org){ opts.debug && log("[patch] error: no own property", prop, "in", obj); return; }
			opts.debug && log("[patch] property descriptor of", prop + ":", org);
			let patched;
			for (let k in org){
				copy[k] = org[k];
				if (typeof org[k] === "function"){
					opts.debug && log("[patch] patching descriptor." + k);
					patched = true;
					copy[k] = patchFunc(org[k], callback, opts);
					patchedFunc[copy[k]] = org[k];
				}
			}
			if (! patched){
				opts.debug && log("[patch] error: descriptor has no get/set/value");
				return;
			}
			opts.debug && log("[patch] defineProperty", prop, copy);
			_defineProperty(obj, prop, copy);
		};
		(function(){
			["entries", "getOwnPropertyDescriptor", "getOwnPropertyDescriptors", "getOwnPropertyNames", "getOwnPropertySymbols", "getPrototypeOf", "hasOwn", "is", "keys", "values"].forEach(prop => {
				patch(Object, prop, function(target, thisArg, args, newTarget){
					for (let i = 0 ; i < args.length ; i++){
						patchedFunc[args[i]] && (args[i] = patchedFunc[args[i]]);
					}
					return _Reflect_apply(target, thisArg, args);
				});
			});
			["hasOwnProperty", "propertyIsEnumerable"].forEach(prop => {
				patch(Object.prototype, prop, function(target, thisArg, args, newTarget){
					patchedFunc[thisArg] && (thisArg = target);
					return _Reflect_apply(target, thisArg, args);
				});
			});
		})();
		return patch;
	})();
	patch(Element.prototype, "attachShadow", (function(){
		const Reflect_apply = Reflect.apply,
				matches = Element.prototype.matches,  test = RegExp.prototype.test,
				join = Array.prototype.join, slice = Array.prototype.slice,
				map = Array.prototype.map, split = String.prototype.split;
		return function(target, thisArg, args, newTarget){
			let v = Reflect_apply(target, thisArg, args), st = makeSt(); 
			try {
				if (matches.call(thisArg, sel) && test.call(stPattern, st)){
					opts.log && log("observing", thisArg, "ShadowRoot", v);
					observe(v, {childList: true});
				}
				else {
					opts.log && log(thisArg, prop, "init:", args[0], (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
				}
			}
			catch(e){ log(e.type || "error", ":", e.message, ":", sel) }; 
			return v;
		};
	})(), opts);
	log("monitoring");
})();

/// avotoko-fake-xhr.js
/// alias avotoko-fxhr.js
(function() {
	const log = function(){
		const _log = console.log, concat = Array.prototype.concat, from = Array.from;
		return function log(){
			_log.apply(console, concat.call(["[avotoko-fake-xhr]"], from(arguments)));
		}
	}();
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		try { s = new RegExp(s, flag); }
		catch (e){ log("RegExp error:", e.message +".", "source:", s, "flags:", flag); return; }
		return s;
	}
	const makeSt = function(){
		const ua =navigator.userAgent, includes = String.prototype.includes,
				split = String.prototype.split, slice = Array.prototype.slice,
				join = Array.prototype.join, _Error = Error;
		return function makeSt(){
			let i = includes.call(ua, "Chrome") ? 3 : includes.call(ua, "Firefox")  ? 2 : 2;
			return join.call(slice.call(split.call(_Error().stack, "\n"), i), "\n");
		}
	}();
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	function parseFilter(s){
		if (typeof s === "undefined"){ log("error: no arguments"); return; }
		let ar = s.split(' ').filter(e=>e), filter = {}, keys = {url:!0, method:!0, body:!0, async:!0};
		for (let i = 0 ; i < ar.length ; i++){
			let e = ar[i], idx = e.indexOf(":"),
				k = idx > -1 ? e.substring(0, idx) : "", v = e.substring(idx+1);
			! keys[k] && (k = "url", v = e);
			if (! v){ log("error: filter has no value:", e); return; }
			if (filter.hasOwnProperty(k)){
				log("error: filter is already defined:", k,":",v);
				return;
			}
			if (k === "async"){
				if (! ["true", "false"].includes(v)){
					log("error: 'async' value must be true or false");
					return;
				}
				v = v === "true";
			}
			else {
				if (! (v = parsePattern(v))){ return; }
			}
			filter[k] = v;
		}
		if (! filter["url"]){ filter["url"] = parsePattern(); }
		if (! filter["method"]){ filter["method"] = parsePattern(); }
		return filter;
	}
	function parseAction(args){
		let action = {}, more = [];
		for (let i = 0 ; i < args.length ; i++){
			let got, obj = action, a = args[i], idx = a.indexOf(":"),
				k = idx === -1 ? a : a.substring(0, idx), v = idx > -1 ? a.substring(idx+1) : void 0;
			if (k === "block"){
				if (v){ log("error: 'block' must have no value"); return; }
				v = got = true;
			}
			else if (k === "trigger"){
				try {
					v = (v || "").split("|").filter(e => {
						if (!(e = e.trim())){ return false; }
						if (! findPropertyDescriptor(XMLHttpRequest, "on" + e)){
							throw Error("xhr doesn't have event: " + e);
						}
						return true;
					});
				}
				catch(e){ log("error:", e.message); return; }
				if (v.length === 0){ log("error: trigger has no event"); return; }
				got = true;
			}
			else if (k.startsWith("set-")){
				k = k.substring(4), v = (v || "").trim();
				if (! k){ log("error: 'set-' missed name:", a); return; }
				if (! v){ log("error: 'set-' missed value:", a); return; }
				if (k.startsWith("header-")){
					k = k.substring(7).toLowerCase();
					obj = action.header = action.header || {};
					if (! k){ log("error: 'set-header-' missed name:", a); return; }
				}
				else {
					obj = action.set = action.set || {};
					let m = k.match(/^(response(?:Text)?)(?:-(.*))?/);
					if (m && m[2]){
						k = m[1];
						if (m[2] === "base64"){
							try { v = atob(v); }
							catch(e){ log("atob error:", e.message, ":", a); return; }
						}
						else {
							let type = m[2];
							// data:[<mediatype>][;base64],<data>
							// /^(data:)([\w\/\+-]*)(;charset=[\w-]+|;base64){0,1},(.*)/gi
							m = v.match(/^data:(;base64)?,(.+)/);
							if (k === "responseText"){
								log("error: responseText support only base64 but not", type); return;
							}
							log("error: response support only base64 but not", type); return;
						}
					}
					if (["readyState", "status"].includes(k)){
						if (isNaN(v = v * 1)){ log("error: value must be number:", a); return; }
					}
					let xhr = XMLHttpRequest.prototype;
					if (! xhr.hasOwnProperty(k)){ log("xhr doesn't have property:", k); return; }
				}
				got = true;
			}
			if (got){
				if (obj.hasOwnProperty(k)){
					log("error: action is already defined:", a);
					return;
				}
				obj[k] = v;
			}
			else {
				if (Object.keys(action).length === 0){ log("error: no actions"); return; }
				more = args.slice(i);
				break;
			}
		}
		return {action, more};
	}
	let mergeHeader = function(){
		let split = String.prototype.split, indexOf = String.prototype.indexOf,
			substring = String.prototype.substring,
			toLowerCase = String.prototype.toLowerCase;
		return function mergeHeader(headers){
			let ah = {};
			for (let k in action.header){ ah[k] = action.header[k]; }
			let nh = "", oh = headers ? split.call(headers, "\r\n") : [];
			for (let i = 0 ; i < oh.length ; i++){
				if (! oh[i]){ continue; }
				let h = oh[i], idx = indexOf.call(h, ":"),
					n = substring.call(h, 0, idx),
					lwr = toLowerCase.call(n),
					v = substring.call(h, idx);
				if (n && ah[lwr]){
					h = n + ": " + ah[lwr];
					delete ah[lwr];
				}
				nh += h + "\r\n";
			}
			for (let k in ah){ nh += k + ": " + ah[k] + "\r\n"; }
			return nh;
		}
	}();
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['://ygosu.com/ method:/get/i', 'block', 'trigger:readystatechange', 'set-readyState:4', 'set-status:200', 'set-response-base64:Qk06AAAAAAAAADYAAAAoAAAAAQAAAAEAAAABABgAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <filters>, <actions>..., <stack trace pattern>, <option>...)
	let filter = parseFilter(arg[0]);
	if (! filter){ return; }
	log("filter:", filter);
	let {action, more} = parseAction(arg.slice(1)) || {};
	if (! action){ return; }
	log("action:", action); 
	log("more:", more); 
	let stPattern = parsePattern(more[0]), opts = parseOpts(more.slice(1));
	if (! (stPattern && opts)){ return; }
	log("stack trace pattern:", stPattern);
	log("options:", opts);
	let obj = XMLHttpRequest.prototype, prop = "open";
    obj[prop] = new Proxy(obj[prop], {
        apply: function(){
			const keys = Object.keys, defineProperty = Object.defineProperty,
				getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
				forEach = Array.prototype.forEach, every = Array.prototype.every,
				map = Array.prototype.map, join = Array.prototype.join,
				slice = Array.prototype.slice, split = String.prototype.split,
				test = RegExp.prototype.test,
				toLowerCase = String.prototype.toLowerCase,
				Reflect_apply = Reflect.apply, _setTimeout = setTimeout,
				dispatchEvent = XMLHttpRequest.prototype.dispatchEvent,
				_URL = URL, _Proxy = Proxy, _Event = Event, _ProgressEvent = ProgressEvent;
			return function(target, thisArg, args ) {
				let method = args[0], url = new _URL(""+args[1], location.href).href, async = args[2],
					st = makeSt(),
					match = test.call(filter.url, url) && test.call(filter.method, method) && test.call(stPattern, st);
				if (match){
					thisArg.send = new _Proxy(thisArg.send, {
						apply: function(target, thisArg, args){
							let body = args[0], match = function(){
								if (! filter.body){ return true; }
								if (args.length === 0){ return false; }
								try {
									body = "" + args[0];
									return test.call(filter.body, body);
								}
								catch(e){ log(e.message, 'when "" + args[0]'); return false; };
							}();
							if (! match){
								opts.log && log("send", body, "to", url, (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
								return Reflect_apply(target, thisArg, args);
							}
							log("got xhr.send", body, "to", url);
							if (action.set){
								let props = {}, obj = XMLHttpRequest.prototype;
								for (k in action.set){ props[k] = action.set[k]; }
								props.responseURL === "*" && (props.responseURL = url);
								forEach.call(keys(props), k => {
									let v = props[k], des = getOwnPropertyDescriptor(obj, k);
									if (des && ! des.configurable){
										log("error: xhr." + k, "is not configurable");
										return;
									}
									defineProperty(thisArg, k, {
										get(){ log("faked xhr." + k); return v; }
									});
								});
							}
							if (action.header){
								forEach.call(["getResponseHeader", "getAllResponseHeaders"], prop=>{
									thisArg[prop] = new Proxy(thisArg[prop], {
										apply: function(target, thisArg, args){
											if (prop === "getResponseHeader"){
												let v = action.header[toLowerCase.call(args[0])];
												if (v){
													log("faked", prop, args[0]);
													return v;
												}
												return Reflect_apply(target, thisArg, args);
											}
											else {
												let v = Reflect_apply(target, thisArg, args);
												return mergeHeader(v);
											}
										},
									});
								});
							}
							if (! action.block){
								return Reflect_apply(target, thisArg, args);
							}
							log("blocked xhr", method, url);
							action.trigger && forEach.call(action.trigger, eventName=>{
								log("faked event", eventName);
								_setTimeout((thisArg, eventName)=>{
									let Ev = eventName === "readystatechange" ? _Event : _ProgressEvent; 
									dispatchEvent.call(thisArg, new Ev(eventName));
								}, 10, thisArg, eventName);
							});
						}
					});
					log("monitoring xhr.send to", url);
				}
				else {
					opts.log && log(prop, method, url, async, (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
				}
				return Reflect_apply(target, thisArg, args);
			}
		}(),
    });
	log("monitoring");
})();

/// avotoko-yet-another-abort-on-stack-trace.js
/// alias avotoko-yaaost.js
// Very experimental
(function() {
    let chain = '{{1}}';
    let needle = '{{2}}';
    let logLevel = '{{3}}';
    let opts = '{{4}}';
    //chain = 'btoa', needle = '/debugger|injectedScript/', logLevel = '1', opts = 'debug:1';
    const reRegexEscape = /[.*+?^${}()|[\]\\]/g;
    if ( needle === '' || needle === '{{2}}' ) {
        needle = '^';
    } else if ( /^\/.+\/$/.test(needle) ) {
        needle = needle.slice(1,-1);
    } else {
        needle = needle.replace(reRegexEscape, '\\$&');
    }
    for (let a = opts.split(" "), i = (opts = {}, 0) ; i < a.length ; i++){
        let kv = a[i], idx = kv.indexOf(':'), k = kv.substring(0, idx), v = kv.substring(idx + 1);
        if (! k){ continue; }
        if (k === "protectionDepth" || k === "stackDepth"){
            Number.isInteger(v = v * 1) && (opts[k] =  v);
        }
        else {
            opts[k] =  v;
        }
    }
    const reNeedle = new RegExp(needle);
    const magic = String.fromCharCode(Math.random() * 26 + 97) +
        Math.floor(
            (0.25 + Math.random() * 0.75) * Number.MAX_SAFE_INTEGER
        ).toString(36).slice(-8);
    const log = console.log.bind(console);
    const ErrorCtor = self.Error;
    const stackDesc = Object.getOwnPropertyDescriptor(ErrorCtor.prototype, "stack"),
            _stackTraceLimit = ErrorCtor.stackTraceLimit,
            _prepareStackTrace = ErrorCtor.prepareStackTrace,
            _exec = RegExp.prototype.exec,
            _test = RegExp.prototype.test,
            _includes = String.prototype.includes,
            _indexOf = String.prototype.indexOf,
            _replace = String.prototype.replace,
            _slice = String.prototype.slice,
            _split = String.prototype.split,
            _startsWith = String.prototype.startsWith,
            _trim = String.prototype.trim,
            _forEach = Array.prototype.forEach;
            _join = Array.prototype.join,
            _push = Array.prototype.push,
            _defineProperty = Object.defineProperty,
            _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
            _getOwnPropertyNames = Object.getOwnPropertyNames,
            _bind = Function.prototype.bind,
            _toString = Function.prototype.toString,
            _toLocaleString = Function.prototype.toLocaleString,
            _Reflect_apply = Reflect.apply,
            _Reflect_construct = Reflect.construct;
            _dummy = void 0;
    const mustAbort = function(err) {
        let docURL = self.location.href;
        const pos = _indexOf.call(docURL, '#');
        if ( pos !== -1 ) {
            docURL = _slice.call(docURL, 0, pos);
        }
        // Normalize stack trace
        const lines = [];
        const _stack = stackDesc ? stackDesc.get.call(err) : err.stack;
        for ( let line of _split.call(_stack, /[\n\r]+/) ) {
            if ( _includes.call(line, magic) ) { continue; }
            line = _trim.call(line);
            let match = _exec.call(/(.*?@)?(\S+)(:\d+):\d+\)?$/, line);
            if ( match === null ) { continue; }
            let url = match[2];
            if ( _startsWith.call(url, '(') ) { url = _slice.call(url, 1); }
            if ( url === docURL ) {
                url = 'inlineScript';
            } else if ( _startsWith.call(url, '<anonymous>') ) {
                url = 'injectedScript';
            }
            let fn = match[1] !== undefined
                ? _slice.call(match[1], 0, -1)
                : _trim.call(_slice.call(line, 0, match.index));
            if ( _startsWith.call(fn, 'at') ) { fn = _trim.call(_slice.call(fn, 2)); }
            let rowcol = match[3];
            lines.push(' ' + _trim.call(`${fn} ${url}${rowcol}:1`));
        }
        lines[0] = `stackDepth:${lines.length-1}`;
        const stack = _join.call(lines, '\t');
        const r = _test.call(reNeedle, stack);
        if (
            logLevel === '1' ||
            logLevel === '2' && r ||
            logLevel === '3' && !r
        ) {
            log(_replace.call(stack, /\t/g, '\n'));
        }
        return r;
    };
    const patchedFunc = {};
	const patchFunc = function(target, callback, opts){
		log("[yaaost] patching function:", target.name);
		let temp = {
			[target.name]: function(){
				const _stl = ErrorCtor.stackTraceLimit, _pst = ErrorCtor.prepareStackTrace;
				ErrorCtor.stackTraceLimit = "stackDepth" in opts ? opts.stackDepth : _stackTraceLimit,
				ErrorCtor.prepareStackTrace = _prepareStackTrace;
				const err = new ErrorCtor(magic);
				ErrorCtor.stackTraceLimit = _stl, ErrorCtor.prepareStackTrace = _pst;
				return callback(target, this, arguments, new.target, err, new ReferenceError(magic));
			},
		}, copy = temp[target.name];
		_forEach.call(_getOwnPropertyNames(target), prop=>{
			copy[prop] = target[prop];
		});
		_defineProperty(copy, "toString", { value: _bind.call(target.toString, target) });
		_defineProperty(copy, "toLocaleString", { value: _bind.call(target.toLocaleString, target) });
        _defineProperty(copy.toLocaleString, "name", { value: "toLocaleString" });
		_defineProperty(copy.toLocaleString, "toString", { value: _bind.call(Function.prototype.toString, target.toLocaleString) });
		const depth = "protectionDepth" in opts ? opts.protectionDepth : 2;
		log("[yaaost] protection depth:", depth);
		for (let obj = copy.toString, 
			obj2 = copy.toLocaleString.toString, 
			toString = _bind.call(_toString, _toString),
			i = 0 ; i < depth ; obj = obj.toString, obj2 = obj2.toString, i++){
			_forEach.call([obj, obj2], obj=>{
				_defineProperty(obj, "name", { value: "toString" });
				_defineProperty(obj, "toString", { value: toString });
			});
		}
		return copy;
	}
    const patch = function (obj, prop, callback, opts){
        opts = opts || {};
        const org = _getOwnPropertyDescriptor(obj, prop), copy = {};
        if (! org){ log("[yaaost] error: no own property", prop, "in", obj); return; }
        log("[yaaost] property descriptor of", prop + ":", org);
        let patched;
        for (let k in org){
            copy[k] = org[k];
            if (typeof org[k] === "function"){
                log("[yaaost] patching descriptor." + k);
                patched = true;
                copy[k] = patchFunc(org[k], callback, opts);
                patchedFunc[copy[k]] = org[k];
            }
        }
        if (! patched){
            log("[yaaost] error: descriptor has no get/set/value");
            return;
        }
        log("[yaaost] defineProperty", prop, copy);
        _defineProperty(obj, prop, copy);
    };
    (function(){
        ["entries", "getOwnPropertyDescriptor", "getOwnPropertyDescriptors", "getOwnPropertyNames", "getOwnPropertySymbols", "getPrototypeOf", "hasOwn", "is", "keys", "values"].forEach(prop => {
            patch(Object, prop, function(target, thisArg, args, newTarget){
                for (let i = 0 ; i < args.length ; i++){
                    patchedFunc[args[i]] && (args[i] = patchedFunc[args[i]]);
                }
                return _Reflect_apply(target, thisArg, args);
            });
        });
        ["hasOwnProperty", "propertyIsEnumerable"].forEach(prop => {
            patch(Object.prototype, prop, function(target, thisArg, args, newTarget){
                patchedFunc[thisArg] && (thisArg = target);
                return _Reflect_apply(target, thisArg, args);
            });
        });
    })();
    const makeProxy = function(owner, chain) {
        const pos = chain.indexOf('.');
        if ( pos === -1 ) {
            patch(owner, chain, function(target, thisArg, args, newTarget, err, refErr){
                if ( mustAbort(err) ) {
                    throw refErr;
                }
                return newTarget ? _Reflect_construct(target, args, newTarget) : _Reflect_apply(target, thisArg, args);
            }, opts);
            return;
        }
        const prop = chain.slice(0, pos);
        let v = owner[prop];
        chain = chain.slice(pos + 1);
        if ( v ) {
            makeProxy(v, chain);
            return;
        }
        log("[yaaost] error: no property", prop, "in", owner);
    };
    const owner = window;
    makeProxy(owner, chain);
    const oe = window.onerror;
    window.onerror = function(msg, src, line, col, error) {
        if ( typeof msg === 'string' && msg.indexOf(magic) !== -1 ) {
            return true;
        }
        if ( oe instanceof Function ) {
            return oe(msg, src, line, col, error);
        }
    }.bind();
})();
