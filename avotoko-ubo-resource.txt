/*
	name:  uBOXSR
	description: avotoko's uBlock Origin Experimental Scriptlets Resource
	author: avotoko
	homepage: https://github.com/avotoko/ubo-resource
	install: add this file url to 'userResourcesLocation' in 'advanced settings'
*/
"use strict";

/// avotoko-fake-promise.js
/// alias avotoko-fp.js
/// alias avotoko-promise-patch.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-promise]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"), a.push("{{11}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	log("arg:", arg);
	// parameters: <invoke type>, <value>, <executor pattern>, <stack trace pattern>, <option>...
	let invoke = arg[0], val = arg[1], execPattern = arg[2], stPattern = arg[3], opts = parseOpts(arg.slice(4));
	if (! opts){ return; }
	log("options:", opts);
	if (! ["resolve", "reject"].includes(invoke)){ log("error: wrong invoke type:", invoke); return; }
	try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return; }
	opts.debug && log("value:", val);
	if (! execPattern){ log("error: executor pattern required"); return; }
	if (! (execPattern = parsePattern(execPattern))){ return; }
	opts.debug && log("executor pattern:", execPattern);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window, prop = "Promise";
	obj[prop] = new Proxy(obj[prop], {
		construct: function(target, args, newTarget){
			const executor = "" + args[0], st = makeSt(),
				match = execPattern.test(executor) && stPattern.test(st);
			if (match){
				log("faked", invoke, val, "aganst", executor);
				if (invoke === "resolve"){
					return new target((resolve,reject)=>{setTimeout(resolve, 1, val)});
				}
				else {
					return new target((resolve,reject)=>{setTimeout(reject, 1, val)});
				}
			}
			else {
				opts.log && log(executor + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
			}
			return Reflect.construct(target, args, newTarget);
		}
	});
	log("monitoring");
})();

/// avotoko-on-handler-defuser.js
/// alias avotoko-ohd.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-on-handler-defuser]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['body', "copy|selectstart|contextmenu", 'return!1', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <window|document|selector>, <event list>, <function pattern>, <stack trace pattern>, <option>...)
	let sel = arg[0], event = arg[1], fnPattern = arg[2], stPattern = arg[3], opts = parseOpts(arg.slice(4));
	if (! opts){ return; }
	log("options:", opts);
	if (! sel){ log("error: selector required"); return; }
	if (! event){ log("error: event required"); return; }
	event = (function(){ return event.split("|").map(e=>e.trim()).filter(e=>e); })();
	if (event.length === 0){ log("error: event name not listed"); return; }
	opts.debug && log("event list", event);
	if (! (fnPattern = parsePattern(fnPattern))){ return; }
	opts.debug && log("function pattern", fnPattern);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack pattern", stPattern);
	let obj = sel === "window" ? window : sel === "document" ? Document.prototype : HTMLElement.prototype;
	event.forEach(name=>{
		let prop = "on" + name;
		let des = findPropertyDescriptor(obj, prop, opts);
		if (! des || ! des.get || ! des.set){ log("error:", prop, "descriptor get/set not found"); return; }
		if (! des.configurable){ log("error:", prop, "descriptor is not configurable"); return; }
		Object.defineProperty(obj, prop, {
			get(){
				return des.get.call(this);
			},
			set(v){
				let fnText = "" + v,
					st = makeSt(),
					match = (! this.matches || this.matches(sel)) && fnPattern.test(fnText) && stPattern.test(st);
				if (match){
					log("defused", this, prop, fnText);
				}
				else {
					opts.log && log(this, prop, fnText  + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
					des.set.call(this, v);
				}
			},
			enumerable: true,
			configurable: true,
		});
	});
	log("monitoring");
})();

/// avotoko-fake-element-property.js
/// alias avotoko-fep.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-element-property]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function parseProps(args){
		let props = {}, more = [];
		for (let i = 0 ; i < args.length ; i++){
			let a = args[i], idx = a.indexOf(":"), key, val;
			if (idx === -1){
				more = args.slice(a === "eova" ? i + 1 : i);
				break;
			}
			key = a.substring(0, idx).trim(), val = a.substring(idx + 1).trim();
			if (! key){ log("error: empty property name:", a); return {}; }
			if (props.hasOwnProperty(key)){ log("error: multiple defined property name:", a); return {}; }
			if (val = val || void 0){
				try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return {}; }
			}
			props[key] = val;
		}
		return {props, more};
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	function derived(obj, from){
		while (obj){
			if (obj === from){ return true; }
			obj = Object.getPrototypeOf(obj);
		}
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['body', 'innerHTML:"<br />"', '', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <selector>, <property>,,, <dom i/f>, <stack trace pattern>, <option>...)
	let sel = arg[0], {props, more} = parseProps(arg.slice(1));
	if (! sel){ log("error: selector required"); return; }
	if (! props){ return; }
	log("props:", props, "more:", more);
	let domif = more[0] || "HTMLElement", stPattern = more[1], opts = parseOpts(more.slice(2));
	if (! opts){ return; }
	log("options:", opts);
	opts.debug && log("properties:", props);
	opts.debug && log("dom i/f:", domif);
	if (! window[domif]){ log("error:", domif, "is not defined"); return; }
	if (! derived(window[domif],  HTMLElement)){ log("error:", domif, "is not derived from HTMLElement"); return; }
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window[domif].prototype;
	Object.keys(props).forEach(prop=>{
		let _val,
			val = props[prop], 
			des = findPropertyDescriptor(obj, prop, opts) || {};
		if (des.hasOwnProperty("configurable") && ! des.configurable){ log("error:", prop, "is not configurable"); return; }
		Object.defineProperty(obj, prop, {
			get(){
				let v = des.get ? des.get.call(this) : des.hasOwnProperty("value") ? des.value : _val;
				try {
					if (this.matches(sel)){
						let st = makeSt(),
							match = stPattern.test(st);
						if (match){
							log("faked get", this, prop, v, "as", val);
							return val;
						}
						else {
							opts.log && log("get", this, prop, v  + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
						}
					}
				}
				catch (e){ log(e.type || "error", ":", e.message, ":", sel) }; 
				return v;
			},
			set(v){
				des.set ? des.set.call(this, v) : des.hasOwnProperty("value") ? (des.value = v) : (_val = v);
			},
			enumerable: true,
			configurable: true,
		});
	});
	log("monitoring");
})();

/// avotoko-fake-gettime-speed.js
/// alias avotoko-fgts.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-gettime-speed]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['1000', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <magnification>, <stack trace pattern>, <option>...)
	let mag = arg[0], stPattern = arg[1], opts = parseOpts(arg.slice(2));
	if (! opts){ return; }
	log("options:", opts);
	if (isNaN(mag = mag * 1)){ log("error: wrong magnification"); return; }
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = Date.prototype, prop = "getTime", start = 0;
	obj[prop] = new Proxy(obj[prop], {
		apply: function(target, thisArg, args) {
			let st = makeSt(),
				match = stPattern.test(st),
				val = Reflect.apply(target, thisArg, args);
			if (match){
				start === 0 && (start = val);
				val = start + Math.ceil((val - start) * mag);
				val < 0 && (val = 0);
				log("faked", prop, "as", val);
				return val;
			}
			else {
				opts.log && log(prop, "as", val, (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : " "));
			}
			return val;
		}
	});
	log("monitoring");
})();

/// avotoko-fake-queryselector-argument.js
/// alias avotoko-fake-getelement-argument.js
/// alias avotoko-fqsa.js
/// alias avotoko-fgea.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-queryselector-argument]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['document', "getElementsByTagName", 'head', 'body', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <document|selector>, <method list>, <argument pattern>, <net argument>, <stack trace pattern>, <option>...)
	let sel = arg[0], props = arg[1], argPattern = arg[2], newArg = arg[3], stPattern = arg[4], opts = parseOpts(arg.slice(5)), method = {querySelector:!0, querySelectorAll:!0, getElementById:!0, getElementsByClassName:!0, getElementsByTagName:!0, getElementsByTagNameNS:!0};
	if (! opts){ return; }
	log("options:", opts);
	if (! sel){ log("error: document or selector required"); return; }
	if (! props){ log("error: method list required"); return; }
	props = props.split(/[ \|]/).map(e=>e.trim()).filter(e=>!!e);
	if (props.length === 0){ log("error: method required"); return; }
	opts.debug && log("method list", props);
	if (props.some(e=>! method[e])){ log("error: wrong method. support", Object.keys(method).join(", ")); return; }
	if (! (argPattern = parsePattern(argPattern))){ return; }
	opts.debug && log("argument pattern", argPattern);
	if (! newArg){ log("error: new argument required"); return; }
	opts.debug && log("new argument", newArg);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack pattern", stPattern);
	let obj = sel === "document" ? document : HTMLElement.prototype, nMonitoring = 0;
	props.forEach(prop=>{
		if (typeof obj[prop] !== "function"){
			log("error:", prop, "in", obj.constructor.name, "is not function");
			return;
		}
		++nMonitoring;
		obj[prop] = new Proxy(obj[prop], {
			apply: function(target, thisArg, args) {
				try {
					if (thisArg === document || thisArg.matches(sel)){
						let i = prop.endsWith("NS") ? 1 : 0,
							argSel =  args[i],
							st = makeSt(),
							match = argPattern.test(argSel) && stPattern.test(st);
						if (match){
							log("faked", thisArg, prop, argSel, "as", newArg);
							args[i] = newArg;
						}
						else {
							opts.log && log(thisArg, prop, argSel + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
						}
					}
				}
				catch(e){ log(e.type, e.message, ":", sel); }
				return Reflect.apply(target, thisArg, args);
			}
		});
	});
	if (nMonitoring > 0){ log("monitoring"); }
})();

/// avotoko-fake-computed-style.js
/// alias avotoko-fcs.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-computed-style]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function parseCssText(cssText){
		let o = {}, n = 0;
		try {
			cssText.split(";").forEach(decl=>{
				if (decl.trim()){
					let i = decl.indexOf(":"), p = decl.substring(0, i).trim(), v = decl.substring(i+1).trim();
					if (! p){ throw Error("wrong css declaration: " + decl); }
					o[p] = v, n++;
				}
			});
		}
		catch (e){ log("error:", e.message); return; }
		if (n === 0){ log("error: css has no declaration"); return; }
		return o;
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return Object.assign({owner: obj}, des);
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"), a.push("{{11}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['#left_nav, #right_nav, .main_preview + div, .logo', ,"display:;", '/debugger|anonymous/', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <selector>, <pseudo-element pattern>, <css>, <stack trace pattern>, <opt>,,,)
	let sel = arg[0], pePattern = arg[1], css = arg[2], stPattern = arg[3], opts = parseOpts(arg.slice(4));
	if (! opts){ return; }
	log("options:", opts);
	if (! sel){ log("error: selector required"); return; }
	opts.debug && log("selector:", sel);
	if (! (pePattern = parsePattern(pePattern))){ return; }
	opts.debug && log("pseudo-element pattern:", pePattern);
	if (! (css = parseCssText(css))){ return; }
	opts.debug && log("css:", css);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window , prop = "getComputedStyle";
	obj[prop] = new Proxy(obj[prop], {
		apply: function(target, thisArg, args) {
			let e = args[0], pe/* pseudo-element */ = args[1], style = Reflect.apply(target, thisArg, args),
				st = makeSt();
			if (style){
				try {
					if (e.matches(sel) && pePattern.test(pe)){
						opts.log && log("got target", e, " " + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
						let prop = "getPropertyValue";
						style[prop] = new Proxy(style[prop], {
							apply: function(target, thisArg, args) {
								let property = args[0], v = Reflect.apply(target, thisArg, args);
								if (css.hasOwnProperty(property)){
									let st = makeSt(), match = stPattern.test(st);
									if (match){
										log("faked", prop, e, property, '"' + v + '"', "as", '"' + css[property] + '"');
										return css[property];
									}
									else {
										opts.log && log(prop, e, property, '"' + v + '"' + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
									}
								}
								return v;
							}
						});
						Object.keys(css).forEach(property=>{
							let val = css[property], 
								des = findPropertyDescriptor(style, property, opts) || {},
								des2 = Object.getOwnPropertyDescriptor(style, property);
							if (! (des.get/*firefox*/ || des.hasOwnProperty("value")/*chrome*/)){
								log("error:", property, "descriptor has no getter/value"); return;
							}
							if (des2 && des2.get){
								log(style[property] === val ? "warning:" : "error:", property, "descriptor getter already defined");
								return;
							}
							Object.defineProperty(style, property, {
								get(){
									let st = makeSt(),
										match = stPattern.test(st),
										v = des.get ? des.get.call(this) : des.value;
									if (match){
										log("faked get", e, property, '"' + v + '"', "as", '"' + val + '"');
										return val;
									}
									else {
										opts.log && log("get", e, property, '"' + v + '"' + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
									}
									return v;
								},
								enumerable: true,
								configurable: true,
							});
						});
					}
				}
				catch(e){ log(e.type, e.message); }
			}
			return style;
		}
	});
	log("monitoring");
})();

/// avotoko-fake-object-property.js
/// alias avotoko-fop.js
(function() {
	function log(){
		console.log.apply(console,["[avotoko-fake-object-property]"].concat(Array.from(arguments)));
	}
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	function makeSt(){
		let ua = navigator.userAgent, i = ua.includes("Chrome") ? 3 : ua.includes("Firefox")  ? 2 : 2;
		return Error().stack.split("\n").slice(i).join("\n");
	}
	function parseProps(args){
		let props = {}, more = [];
		for (let i = 0 ; i < args.length ; i++){
			let a = args[i], idx = a.indexOf(":"), key, val;
			if (idx === -1){
				more = args.slice(a === "eova" ? i + 1 : i);
				break;
			}
			key = a.substring(0, idx).trim(), val = a.substring(idx + 1).trim();
			if (! key){ log("error: empty property name:", a); return {}; }
			if (props.hasOwnProperty(key)){ log("error: multiple defined property name:", a); return {}; }
			if (val = val || void 0){
				try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return {}; }
			}
			props[key] = val;
		}
		return {props, more};
	}
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	function parseChain(chain){
		let prop = [], s = chain, m;
		if (! (m = s.match(/^(\w+)(.*)/))){ log("error: chain must start with identifier"); return; }
		m[1] !== "window" && prop.push("window");
		prop.push(m[1]), s = m[2];
		while (s){
			if (! (m = s.match(/(\.(\w+)|\['(.+)'\]|\["(.+)"\])(.*)/))){ log("error: wrong property"); return; }
			prop.push(m[2] || m[3] || m[4]), s = m[5];
		}
		if (prop.length === 1){ log("error: chain has no property"); return; }
		return prop;
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	// arg = ['setTimeout', 'toString:"function(){[native code]}"', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <object>, <property>..., <stack trace pattern>, <option>...)
	let chain = arg[0], {props, more} = parseProps(arg.slice(1));
	if (! props){ return; }
	log("props:", props, "more:", more);
	let stPattern = more[0], opts = parseOpts(more.slice(1));
	if (! opts){ return; }
	log("options:", opts);
	if (! (chain = parseChain(chain))){ return; }
	opts.debug && log("object:", chain);
	opts.debug && log("properties:", props);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window;
	for (let i = 1 ; i < chain.length ; i++){
		try {
			obj = obj[chain[i]];
			if (! obj){ log("error:", chain.slice(0,i+1).join("."), "not defined"); return; }
		} catch(e){ log(e.type || "error", ":", e.message, ":", chain.slice(0,i+1).join(".")); return; }
	}
	opts.debug && log("object:", obj);
	Object.keys(props).forEach(prop=>{
		let _val,
			val = props[prop], fval = function(){ return props[prop]; };
			des = findPropertyDescriptor(obj, prop, opts) || {};
		if (des.hasOwnProperty("configurable") && ! des.configurable){ log("error:", prop, "is not configurable"); return; }
		Object.defineProperty(obj, prop, {
			get(){
				let v = des.get ? des.get.call(this) : des.hasOwnProperty("value") ? des.value : _val;
				let st = makeSt(), match = stPattern.test(st);
				if (match){
					log("faked get", this, prop, v, "as", val);
					return typeof v === "function" ? fval : val;
				}
				else {
					opts.log && log("get", this, prop, v  + (opts.st > 0 ? "\n" + st.split("\n").map(e=>"  "+e).slice(0, opts.st).join("\n") : ""));
				}
				return v;
			},
			set(v){
				des.set ? des.set.call(this, v) : des.hasOwnProperty("value") ? (des.value = v) : (_val = v);
			},
			enumerable: true,
			configurable: true,
		});
	});
	log("monitoring");
})();

/// avotoko-fake-object-method.js
/// alias avotoko-fom.js
(function() {
	const log = function(){
		const _log = console.log, concat = Array.prototype.concat, from = Array.from;
		return function log(){
			_log.apply(console, concat.call(["[avotoko-fake-object-method]"], from(arguments)));
		}
	}();
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	const makeSt = function(){
		const ua =navigator.userAgent, includes = String.prototype.includes,
				split = String.prototype.split, slice = Array.prototype.slice,
				join = Array.prototype.join, _Error = Error;
		return function makeSt(){
			let i = includes.call(ua, "Chrome") ? 3 : includes.call(ua, "Firefox")  ? 2 : 2;
			return join.call(slice.call(split.call(_Error().stack, "\n"), i), "\n");
		}
	}();
	const toString = function(){
		const map = Array.prototype.map, join = Array.prototype.join,
			push = Array.prototype.push, pop = Array.prototype.pop, 
			forEach = Array.prototype.forEach, a_includes = Array.prototype.includes,
			s_includes = String.prototype.includes, substring = String.prototype.substring,
			keys = Object.keys, sym_toString = Symbol.prototype.toString;
		return function toString(v, depth, recur){
			depth = depth || 0, recur = recur || [];
			if (v instanceof Array){
				return "[" + join.call(map.call(v, e=>toString(e, depth+1, recur)), ", ") + "]";
			}
			else if (v instanceof Element){
				return v.outerHTML;
			}
			else if (v instanceof Node){
				return v.nodeName + " " + toString(v.textContent || "");
			}
			else if (typeof v === "object" && v !== null){
				if (a_includes.call(recur, v)){ return "[recursive object]"; }
				else if (depth > 2){ return "[too deep object]"; }
				push.call(recur, v);
				let s = "";
				forEach.call(keys(v), k => {
					s += ", " + k + ": " + toString(v[k], depth+1, recur);
				});
				pop.call(recur);
				return s ? "{ " + substring.call(s, 2) + " }" : "{}";
			}
			else if (typeof v === "symbol"){
				return sym_toString.call(v);
			}
			else {
				return "" + v;
			}
		}
	}();
	function parseVArgs(args){
		let noarg, more = [], hash = {}, maxIdx = -1;
		for (let i = 0 ; i < args.length ; i++){
			let a = args[i].trim(), idx;
			if (! (m = a.match(/^(\d+):(.*)/))){
				if (a === "noarg"){
					if (maxIdx !== -1){ log("error: 'noarg' with arg(s)"); return {}; }
					noarg = true;
				}
				more = args.slice(["noarg", "eova"].includes(a) ? i + 1 : i);
				break;
			}
			idx = m[1] * 1;
			if (hash.hasOwnProperty(idx)){ log("error: multiple defined arg index:", a); return {}; }
			if ((hash[idx] = parsePattern(m[2].trim())) === void 0){ return {}; }
			maxIdx = Math.max(maxIdx, idx);
		}
		let varg = new Array(maxIdx + 1), v;
		for (let i = 0 ; i < maxIdx + 1; i++){
			varg[i] = hash[i] || /(?:)/;
		}
		varg.noarg = noarg;
		return {varg, more};
	}
	function parseChain(chain, type, minLength){
		let prop = [], s = chain, m;
		if (! (m = s.match(/^(\w+)(.*)/))){ log("error: chain must start with identifier"); return; }
		m[1] !== "window" && prop.push("window");
		prop.push(m[1]), s = m[2];
		while (s){
			if (! (m = s.match(/(\.(\w+)|\['(.+)'\]|\["(.+)"\])(.*)/))){ log("error: wrong property"); return; }
			prop.push(m[2] || m[3] || m[4]), s = m[5];
		}
		if (prop.length < minLength){ log("error: chain has no " + type); return; }
		return prop;
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['atob', '"hello"', 'noarg', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <object.method>, <return value>, <arg pattern>..., <stack trace pattern>, <option>...)
	let chain = arg[0], prop, val = arg[1], {varg, more} = parseVArgs(arg.slice(2)); 
	if (! varg){ return; }
	log("varg:", (varg.noarg ? "noarg" : varg), "more:", more);
	let stPattern = more[0], opts = parseOpts(more.slice(1));
	if (! opts){ return; }
	log("options:", opts);
	if (! (chain = parseChain(chain, "method", 2))){ return; }
	prop = chain.splice(chain.length - 1)[0];
	opts.debug && log("object:", chain);
	opts.debug && log("method:", prop);
	if (val = val || void 0){
		try { val = JSON.parse(val) } catch(e){ log("error: wrong value:", e.message, ":", val); return; }
	}
	opts.debug && log("return value:", typeof val === "string" ? toString(val) : val);
	opts.debug && log("arg pattern:", varg);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	let obj = window;
	for (let i = 1 ; i < chain.length ; i++){
		try {
			obj = obj[chain[i]];
			if (! obj){ log("error:", chain.slice(0,i+1).join("."), "not defined"); return; }
		} catch(e){ log(e.type || "error", ":", e.message, ":", chain.slice(0,i+1).join(".")); return; }
	}
	opts.debug && log("object:", obj);
	if (typeof obj[prop] !== "function"){log("error:", prop, "is not function"); return;}
	obj[prop] = new Proxy(obj[prop], {
		apply: function(){
			const map = Array.prototype.map, join = Array.prototype.join, 
				every = Array.prototype.every, slice = Array.prototype.slice,
				split = String.prototype.split, test = RegExp.prototype.test,
				Reflect_apply = Reflect.apply;
			return function(target, thisArg, args) {
				const argsText = join.call(map.call(args, (e,i) => i + ":" + toString(e)) ,", "),
					st = makeSt(),
					match = (varg.noarg ? args.length === 0 : args.length === 0 ? varg.length === 0 : every.call(varg, (rex,i)=> test.call(rex, toString(args[i]))))
								&& test.call(stPattern, st);
				if (match){
					log("faked", thisArg, prop, argsText);
					return val;
				}
				else {
					opts.log && log(thisArg, prop, argsText, (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
				}
				return Reflect_apply(target, thisArg, args);
			}
		}()
	});
	log("monitoring");
})();

/// avotoko-no-shadow-root.js
/// alias avotoko-nosr.js
(function() {
	const log = function(){
		const _log = console.log, concat = Array.prototype.concat, from = Array.from;
		return function log(){
			_log.apply(console, concat.call(["[ avotoko-no-shadow-root]"], from(arguments)));
		}
	}();
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		if (s){
			try { s = new RegExp(s, flag); }
			catch (e){ log("RegExp error:", e.message, ":", s); return; }
		}
		return s;
	}
	const makeSt = function(){
		const ua =navigator.userAgent, includes = String.prototype.includes,
				split = String.prototype.split, slice = Array.prototype.slice,
				join = Array.prototype.join, _Error = Error;
		return function makeSt(){
			let i = includes.call(ua, "Chrome") ? 3 : includes.call(ua, "Firefox")  ? 2 : 2;
			return join.call(slice.call(split.call(_Error().stack, "\n"), i), "\n");
		}
	}();
	function parseOptions(s){
		s = s || "";
		const available = {
			"delay": v=> ! isNaN(v*1),
		};
		let options = {}, ar = s.split(" ").filter(e=>e);
		for (let i = 0 ; i < ar.length ; i++){
			let opt = ar[i], idx = opt.indexOf(":"), key, val;
			if (idx === -1){ log("error: ':' missed at", opt); return; }
			key = opt.substring(0, idx).trim(), val = opt.substring(idx + 1).trim();
			if (! key){ log("error: option name required:", opt); return; }
			if (! val){ log("error: option value required:", opt); return; }
			if (! available.hasOwnProperty(key)){ log("error: unknown option:", opt); return; }
			if (! available[key](val)){ log("error: wrong value:", opt); return; }
			if (options.hasOwnProperty(key)){ log("error: multiple defined option:", opt); return; }
			options[key] = val;
		}
		return options;
	}
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['div', 'delay:100', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <selector>, <options>, <stack trace pattern>, <option>...)
	let sel = arg[0] || "*", options = arg[1], stPattern = arg[2], opts = parseOpts(arg.slice(3));
	if (! opts){ return; }
	log("debug options:", opts);
	opts.debug && log("selector:", sel);
	if (! (options = parseOptions(options))){ return; }
	options.delay = options.hasOwnProperty("delay") ? options.delay * 1 : 0;
	opts.debug && log("command options:", options);
	if (! (stPattern = parsePattern(stPattern))){ return; }
	opts.debug && log("stack trace pattern:", stPattern);
	const observe = function(){
		const _setTimeout = setTimeout,
				Element_remove = Element.prototype.remove,
				Array_forEach = Array.prototype.forEach;
		const observer = new MutationObserver((mutations, observer)=>{
			Array_forEach.call(mutations, (m,j)=>{
				if (m.type === "childList"){
					m.addedNodes.forEach((e,i)=>{
						opts.log && log("added and removing", e);
						if (options.delay === 0){
							Element_remove.call(e);
						}
						else {
							_setTimeout.call(null, function(e, remove){
								Element_remove.call(e);
							}, options.delay, e, Element_remove);
						}
					});
				}
			});
		});
		return observer.observe.bind(observer);
	}();
	let obj = Element.prototype, prop = "attachShadow";
	obj[prop] = new Proxy(obj[prop], {
		apply: function(){
			const Reflect_apply = Reflect.apply,
					matches = Element.prototype.matches,  test = RegExp.prototype.test,
					join = Array.prototype.join, slice = Array.prototype.slice,
					map = Array.prototype.map, split = String.prototype.split;
			return function(target, thisArg, args) {
				let v = Reflect_apply(target, thisArg, args), st = makeSt(); 
				try {
					if (matches.call(thisArg, sel) && test.call(stPattern, st)){
						opts.log && log("observing", thisArg, "ShadowRoot", v);
						observe(v, {childList: true});
					}
					else {
						opts.log && log(thisArg, prop, "init:", args[0], (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
					}
				}
				catch(e){ log(e.type || "error", ":", e.message, ":", sel) }; 
				return v;
			}
		}(),
	});
	log("monitoring");
})();

/// avotoko-fake-xhr.js
/// alias avotoko-fxhr.js
(function() {
	const log = function(){
		const _log = console.log, concat = Array.prototype.concat, from = Array.from;
		return function log(){
			_log.apply(console, concat.call(["[avotoko-fake-xhr]"], from(arguments)));
		}
	}();
	function parseOpts(args){
		let opts = {};
		for (let idx = 0 ; idx < args.length ; idx++){
			let a = args[idx], i= a.indexOf(":"), name = a.substring(0, i).trim(), val = a.substring(i+1).trim();
			val = /^\d+$/.test(val) ? val * 1 : NaN;
			if (! ["debug","log","st"].includes(name) || isNaN(val)){ log("error: wrong option:", a); return}
			opts[name] = val;
		}
		return opts;
	}
	function parsePattern(s){
		let m, flag = "";
		if (! s){ return /(?:)/; }
		if (m = s.match(/^\/(.*)\/(\w*)$/)){
			s = m[1], flag = m[2];
		}
		else {
			s = s.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
		}
		try { s = new RegExp(s, flag); }
		catch (e){ log("RegExp error:", e.message +".", "source:", s, "flags:", flag); return; }
		return s;
	}
	const makeSt = function(){
		const ua =navigator.userAgent, includes = String.prototype.includes,
				split = String.prototype.split, slice = Array.prototype.slice,
				join = Array.prototype.join, _Error = Error;
		return function makeSt(){
			let i = includes.call(ua, "Chrome") ? 3 : includes.call(ua, "Firefox")  ? 2 : 2;
			return join.call(slice.call(split.call(_Error().stack, "\n"), i), "\n");
		}
	}();
	function findPropertyDescriptor(obj, prop, opts){
		function getObjName(obj){
			return obj.hasOwnProperty("constructor") ? obj.constructor.name + " Prototype" : obj.name || obj.constructor.name;
		}
		let depth = 0;
		opts = opts || {};
		opts.debug && log("searching for a descriptor of", prop);
		if (! prop){ opts.debug && log(depth, ":", "no property name"); return; }
		while (obj){
			opts.debug && log(depth, ":", getObjName(obj));
			if (obj.hasOwnProperty(prop)){
				let des = Object.getOwnPropertyDescriptor(obj, prop);
				opts.debug && log("descriptor", des);
				return des;
			}
			obj = obj.prototype || Object.getPrototypeOf(obj);
			depth++;
		}
		opts.debug && log(depth,":","descriptor not found");
	}
	function parseFilter(s){
		if (typeof s === "undefined"){ log("error: no arguments"); return; }
		let ar = s.split(' ').filter(e=>e), filter = {}, keys = {url:!0, method:!0, body:!0, async:!0};
		for (let i = 0 ; i < ar.length ; i++){
			let e = ar[i], idx = e.indexOf(":"),
				k = idx > -1 ? e.substring(0, idx) : "", v = e.substring(idx+1);
			! keys[k] && (k = "url", v = e);
			if (! v){ log("error: filter has no value:", e); return; }
			if (filter.hasOwnProperty(k)){
				log("error: filter is already defined:", k,":",v);
				return;
			}
			if (k === "async"){
				if (! ["true", "false"].includes(v)){
					log("error: 'async' value must be true or false");
					return;
				}
				v = v === "true";
			}
			else {
				if (! (v = parsePattern(v))){ return; }
			}
			filter[k] = v;
		}
		return filter;
	}
	function parseAction(args){
		let action = {}, more = [];
		for (let i = 0 ; i < args.length ; i++){
			let got, obj = action, a = args[i], idx = a.indexOf(":"),
				k = idx === -1 ? a : a.substring(0, idx), v = idx > -1 ? a.substring(idx+1) : void 0;
			if (k === "block"){
				if (v){ log("error: 'block' must have no value"); return; }
				v = got = true;
			}
			else if (k === "trigger"){
				try {
					v = (v || "").split("|").filter(e => {
						if (!(e = e.trim())){ return false; }
						if (! findPropertyDescriptor(XMLHttpRequest, "on" + e)){
							throw Error("xhr doesn't have event: " + e);
						}
						return true;
					});
				}
				catch(e){ log("error:", e.message); return; }
				if (v.length === 0){ log("error: trigger has no event"); return; }
				got = true;
			}
			else if (k.startsWith("set-")){
				k = k.substring(4), v = (v || "").trim();
				if (! k){ log("error: 'set-' missed name:", a); return; }
				if (! v){ log("error: 'set-' missed value:", a); return; }
				if (k.startsWith("header-")){
					k = k.substring(7).toLowerCase();
					obj = action.header = action.header || {};
					if (! k){ log("error: 'set-header-' missed name:", a); return; }
				}
				else {
					obj = action.set = action.set || {};
					let m = k.match(/^(response(?:Text)?)(?:-(.*))?/);
					if (m && m[2]){
						k = m[1];
						if (m[2] === "base64"){
							try { v = atob(v); }
							catch(e){ log("atob error:", e.message, ":", a); return; }
						}
						else {
							let type = m[2];
							// data:[<mediatype>][;base64],<data>
							// /^(data:)([\w\/\+-]*)(;charset=[\w-]+|;base64){0,1},(.*)/gi
							m = v.match(/^data:(;base64)?,(.+)/);
							if (k === "responseText"){
								log("error: responseText support only base64 but not", type); return;
							}
							log("error: response support only base64 but not", type); return;
						}
					}
					if (["readyState", "status"].includes(k)){
						if (isNaN(v = v * 1)){ log("error: value must be number:", a); return; }
					}
					let xhr = XMLHttpRequest.prototype;
					if (! xhr.hasOwnProperty(k)){ log("xhr doesn't have property:", k); return; }
				}
				got = true;
			}
			if (got){
				if (obj.hasOwnProperty(k)){
					log("error: action is already defined:", a);
					return;
				}
				obj[k] = v;
			}
			else {
				if (Object.keys(action).length === 0){ log("error: no actions"); return; }
				more = args.slice(i);
				break;
			}
		}
		return {action, more};
	}
	let mergeHeader = function(){
		let split = String.prototype.split, indexOf = String.prototype.indexOf,
			substring = String.prototype.substring,
			toLowerCase = String.prototype.toLowerCase;
		return function mergeHeader(headers){
			let ah = {};
			for (let k in action.header){ ah[k] = action.header[k]; }
			let nh = "", oh = headers ? split.call(headers, "\r\n") : [];
			for (let i = 0 ; i < oh.length ; i++){
				if (! oh[i]){ continue; }
				let h = oh[i], idx = indexOf.call(h, ":"),
					n = substring.call(h, 0, idx),
					lwr = toLowerCase.call(n),
					v = substring.call(h, idx);
				if (n && ah[lwr]){
					h = n + ": " + ah[lwr];
					delete ah[lwr];
				}
				nh += h + "\r\n";
			}
			for (let k in ah){ nh += k + ": " + ah[k] + "\r\n"; }
			return nh;
		}
	}();
	log("start on", location.href);
	let arg = (function(){
		let a = []; a.push("{{1}}"), a.push("{{2}}"), a.push("{{3}}"), a.push("{{4}}"), a.push("{{5}}"), 
		a.push("{{6}}"), a.push("{{7}}"), a.push("{{8}}"), a.push("{{9}}"), a.push("{{10}}"),
		a.push("{{11}}"), a.push("{{12}}"), a.push("{{13}}"), a.push("{{14}}"), a.push("{{15}}");
		for (let i = 0 ; i < a.length ; i++){ if (a[i] === "{{" + (i+1) + "}}"){ a.splice(i); break; } }
		return a;
	})();
	//arg = ['://ygosu.com/ method:/get/i', 'block', 'trigger:readystatechange', 'set-readyState:4', 'set-status:200', 'set-response-base64:Qk06AAAAAAAAADYAAAAoAAAAAQAAAAEAAAABABgAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==', 'debugger', 'debug:1', 'log:1', 'st:10'];
	log("arg:", arg);
	// param: <filters>, <actions>..., <stack trace pattern>, <option>...)
	let filter = parseFilter(arg[0]);
	if (! filter){ return; }
	log("filter:", filter);
	let {action, more} = parseAction(arg.slice(1)) || {};
	if (! action){ return; }
	log("action:", action); 
	log("more:", more); 
	let stPattern = parsePattern(more[0]), opts = parseOpts(more.slice(1));
	if (! (stPattern && opts)){ return; }
	log("stack trace pattern:", stPattern);
	log("options:", opts);
	let obj = XMLHttpRequest.prototype, prop = "open";
    obj[prop] = new Proxy(obj[prop], {
        apply: function(){
			const keys = Object.keys, defineProperty = Object.defineProperty,
				getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
				forEach = Array.prototype.forEach, every = Array.prototype.every,
				map = Array.prototype.map, join = Array.prototype.join,
				slice = Array.prototype.slice, split = String.prototype.split,
				test = RegExp.prototype.test,
				toLowerCase = String.prototype.toLowerCase,
				Reflect_apply = Reflect.apply, _setTimeout = setTimeout,
				dispatchEvent = XMLHttpRequest.prototype.dispatchEvent,
				_URL = URL, _Proxy = Proxy, _Event = Event, _ProgressEvent = ProgressEvent;
			return function(target, thisArg, args ) {
				let method = args[0], url = new _URL(""+args[1], location.href).href, async = args[2],
					st = makeSt(),
					match = test.call(filter.url, url) && test.call(filter.method, method) && test.call(stPattern, st);
				if (match){
					thisArg.send = new _Proxy(thisArg.send, {
						apply: function(target, thisArg, args){
							let body = args[0], match = function(){
								if (! filter.body){ return true; }
								if (args.length === 0){ return false; }
								try {
									body = "" + args[0];
									return test.call(filter.body, body);
								}
								catch(e){ log(e.message, 'when "" + args[0]'); return false; };
							}();
							if (! match){
								opts.log && log("send", body, "to", url, (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
								return Reflect_apply(target, thisArg, args);
							}
							log("got xhr.send", body, "to", url);
							if (action.set){
								let props = {}, obj = XMLHttpRequest.prototype;
								for (k in action.set){ props[k] = action.set[k]; }
								props.responseURL === "*" && (props.responseURL = url);
								forEach.call(keys(props), k => {
									let v = props[k], des = getOwnPropertyDescriptor(obj, k);
									if (des && ! des.configurable){
										log("error: xhr." + k, "is not configurable");
										return;
									}
									defineProperty(thisArg, k, {
										get(){ log("faked xhr." + k); return v; }
									});
								});
							}
							if (action.header){
								forEach.call(["getResponseHeader", "getAllResponseHeaders"], prop=>{
									thisArg[prop] = new Proxy(thisArg[prop], {
										apply: function(target, thisArg, args){
											if (prop === "getResponseHeader"){
												let v = action.header[toLowerCase.call(args[0])];
												if (v){
													log("faked", prop, args[0]);
													return v;
												}
												return Reflect_apply(target, thisArg, args);
											}
											else {
												let v = Reflect_apply(target, thisArg, args);
												return mergeHeader(v);
											}
										},
									});
								});
							}
							if (! action.block){
								return Reflect_apply(target, thisArg, args);
							}
							log("blocked xhr", method, url);
							action.trigger && forEach.call(action.trigger, eventName=>{
								log("faked event", eventName);
								_setTimeout((thisArg, eventName)=>{
									let Ev = eventName === "readystatechange" ? _Event : _ProgressEvent; 
									dispatchEvent.call(thisArg, new Ev(eventName));
								}, 10, thisArg, eventName);
							});
						}
					});
					log("monitoring xhr.send to", url);
				}
				else {
					opts.log && log(prop, method, url, async, (opts.st > 0 ? "\n" + join.call(slice.call(map.call(split.call(st,"\n"), e=>"  "+e), 0, opts.st), "\n") : " "));
				}
				return Reflect_apply(target, thisArg, args);
			}
		}(),
    });
	log("monitoring");
})();

